/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package fmiquerytest;

import java.awt.Desktop;
import java.net.URL;
import java.net.URLConnection;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import static java.lang.Boolean.FALSE;
import static java.lang.Boolean.TRUE;
import static java.lang.Integer.parseInt;
import java.net.MalformedURLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import static java.lang.Math.pow;
import static java.lang.Math.sqrt;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.text.DecimalFormat;
import static oracle.jrockit.jfr.events.Bits.intValue;

class Coordinates implements Serializable
{
    public double Lat; 
    public double Lon;  
    // constructor
    public Coordinates(double Lat, double Lon)
    {
        this.Lat = Lat;
        this.Lon = Lon;
    }
}
class distance implements Comparable<distance> 
{
    public int stationNum;
    public double stationDistance;
    
    @Override
    public int compareTo(distance o) {
        return Double.compare(this.stationDistance, o.stationDistance);
    }
    public distance(int stationNum, double stationDistance)
    {
        this.stationNum = stationNum;
        this.stationDistance = stationDistance;
    }
}
class routeStep implements Serializable
{
    public Coordinates StartLocation;
    public Coordinates EndLocation;
    public int Distance;
    public int Duration;
    // constructor
    public routeStep(Coordinates StartLocation, Coordinates EndLocation,
            int Distance, int Duration)
    {
        this.StartLocation = StartLocation;
        this.EndLocation = EndLocation;
        this.Distance = Distance;
        this.Duration = Duration;
    }
}
class routePoint
{
    public Coordinates Coords;
    public int nearestStation;
    // constructor
    public routePoint(Coordinates Coords, int nearestStation)
    {
        this.Coords = Coords;
        this.nearestStation = nearestStation;
    }
}
class weatherData implements Serializable
{
    public String isoTime;
    public String parameterName;
    public String parameterValue;
    // constructor
    public weatherData(String isoTime, String parameterName,
            String parameterValue)
    {
        this.isoTime = isoTime;
        this.parameterName = parameterName;
        this.parameterValue = parameterValue;
    }
}
class stationData implements Serializable
{
    public Coordinates stationLocation;
    public String stationName;
    public List<weatherData> weatherData;
    // constructor
    public stationData(Coordinates stationLocation, String stationName,
            List<weatherData> weatherData)
    {
        this.stationLocation = stationLocation;
        this.stationName = stationName;
        this.weatherData = weatherData;
    }
}

class RouteTools
{
    //    interpolate_step(step,curr_step,curr_coords)
    //    start_point = curr_step
    //    end_point = curr_step + step.duration
    //    for i in (start_point:end_point)
    //        lat = curr_coords[1]+(step.end_location[1]-curr_coords[1])/(step.duration)*(i-curr_step)
    //        lon = curr_coords[2]+(step.end_location[2]-curr_coords[2])/(step.duration)*(i-curr_step)
    //    end for
    static Coordinates interpolateOnePoint(routeStep step, int currPoint, int startPoint){
        Coordinates currCoor = step.StartLocation;
        double lat = currCoor.Lat 
                + (step.EndLocation.Lat-currCoor.Lat)/step.Duration*(currPoint-startPoint);
        double lon = currCoor.Lon 
                + (step.EndLocation.Lon-currCoor.Lon)/step.Duration*(currPoint-startPoint);
        Coordinates corrNow = new Coordinates(lat, lon);
        return corrNow;
    }
    
    //    current_step = 0
    //    current_coordinates = start_coordinates
    //    for i in length(steps)
    //    append(steps, interpolate_step(steps[i]),current_step,current_coordinates)
    //    current_step = current_step + steps[i].duration
    //    current_coordinates = steps[i].end_location
    //    end for
    static List<routeStep> stepsToRoute(List<routeStep> gSteps, 
                                Coordinates routeStart, int routeDur, int refreshInterval){
        List<routeStep> routeTemp = new ArrayList<>();
        //System.out.println("routeTemp.length: "+routeTemp.size());
        int currentTime = 0;
        Coordinates currentCoords = routeStart;
        // Loop the gSteps
        for(int i=0; i < gSteps.size();i++){
            int startPoint = currentTime;
            int endPoint = currentTime + gSteps.get(i).Duration;
            // Loop the points of one step
//            for(int j=startPoint; j < endPoint;j++){
//                //System.out.println("j: "+j);
//                routeTemp[j] = new routePoint(RouteTools.interpolateOnePoint(gSteps.get(i), j, 
//                        startPoint, currentCoords), 0);
//            }
            //System.out.println(refreshInterval);
            //System.out.println(gSteps.get(i).Duration);
            double fractionOfRoute = ((double)refreshInterval/(double)gSteps.get(i).Duration);
            //System.out.println(fractionOfRoute);
            int oneIntervalDistance = intValue(gSteps.get(i).Distance*(fractionOfRoute));
            int totalDistance = 0;
            while((currentTime+refreshInterval) < endPoint){
                currentTime += refreshInterval;
                Coordinates startCoords = currentCoords;
                currentCoords = RouteTools.interpolateOnePoint(gSteps.get(i),currentTime,startPoint);
                routeTemp.add(new routeStep(startCoords,currentCoords,oneIntervalDistance,refreshInterval));
                totalDistance += oneIntervalDistance;
            }
            routeTemp.add(new routeStep(currentCoords,gSteps.get(i).EndLocation,
                    gSteps.get(i).Distance-totalDistance,gSteps.get(i).Duration-(currentTime-startPoint)));
            currentTime = endPoint;
            currentCoords = gSteps.get(i).EndLocation;           
//            System.out.format("%-7s%-10s%-5s%-10s%-7s%-12s %-12s\n",
//                    "Start: ",startPoint,"End: ",endPoint,"Coord: ",currentCoords.Lat,currentCoords.Lon);
        }
        return routeTemp;
    }

    static double euclideanDistance(Coordinates targetCoordinates, Coordinates stationCoordinates){
        double distance = sqrt(pow((targetCoordinates.Lat-stationCoordinates.Lat),2)
                +pow((targetCoordinates.Lon-stationCoordinates.Lon),2));
        return distance;
    }
    
    static distance[] calculateStationDistances(Coordinates currentPoint, List<stationData> allStations){
        distance[] stationDistances = new distance[allStations.size()];
        for (int i=0; i < allStations.size();i++){
            stationDistances[i] = 
                    new distance(i, euclideanDistance(currentPoint,allStations.get(i).stationLocation));
//            System.out.format("%-12s%-4s%-10s%-10s\n",
//                   "stationNum: ",stationDistances[i].stationNum,
//                   "distance: ",stationDistances[i].stationDistance);
        }
        Arrays.sort(stationDistances);
        return stationDistances;
    }
    
    static int findNearestStation(Coordinates currentPoint, List<stationData> allStations){
        //max stationDistance from origin (current) coordinates is 2x stationDistance travelled + nearest station in the otigin
        //double maxDistance = 2*euclideanDistance(target_coordinates,origin_coordinates)+station_distances[1].stationDistance
        //# this takes into account for example the situation where the route is so short that the station does not change
        //# for long trip (Helsinki-Ivalo) it may be good idea to trigger the station stationDistance table calculation again
        //# (to produce new station list where the more relevant stations are on the top)
        //# take all points that are closer than max stationDistance
        //near_stations = station_distances LESS_THAN max_distance
        //if (length(near_stations MORE_THAN 30){
        //# NOTE. Change values that are stored in the main program level
        //# These will be used later
        //calculate_station_distances(station_distances,target_coordinates)
        //}
        //else {
        //# calculate current distances to those stations
        //results = calculate_station_distances(near_stations,target_coordinates)
        //nearest = sort(results,ASCENDING)[1]
        //}
        //return nearest
        return 0;
    }
    static List<routeStep> compileRoute(List<routeStep> gSteps, Integer refreshInterval){
        Coordinates routeStart = gSteps.get(0).StartLocation;
        System.out.format("%-12s%-12s%-12s%-12s\n","Start Lat: ",routeStart.Lat,"Start Lon: ",routeStart.Lon);
        Coordinates routeEnd = gSteps.get(gSteps.size()-1).EndLocation;
        System.out.format("%-12s%-12s%-12s%-12s\n","End Lat: ",routeEnd.Lat,"End Lon: ",routeEnd.Lon);
        int routeDist = 0;
        for(int i=0; i < gSteps.size();i++)
            routeDist += gSteps.get(i).Distance;
        System.out.println("Google route distance: "+routeDist+" (m)");
        //int routeDur = 0;
        for(int i=0; i < gSteps.size();i++)
            FmiQueryTest.routeDur += gSteps.get(i).Duration;
        System.out.println("Google route duration: "+FmiQueryTest.routeDur+" (s)");
        List<routeStep> routeData = new ArrayList<>();
        routeData = RouteTools.stepsToRoute(gSteps, routeStart, FmiQueryTest.routeDur, refreshInterval);
        
        //Add endpoint to Google steps
        routeData.add(new routeStep(routeEnd, routeEnd, 0, 0));
        
        return routeData;
    }
}

class ToolBox {
    // Not used?
    static String getURLContent(String p_sURL)
    {
        URL oURL;
        URLConnection oConnection;
        BufferedReader oReader;
        String sLine;
        StringBuilder sbResponse;
        String sResponse = null;
            
        try {
            oURL = new URL(p_sURL);
            oConnection = oURL.openConnection();
            oReader = new BufferedReader(new InputStreamReader(oConnection.getInputStream()));
            sbResponse = new StringBuilder();
            while((sLine = oReader.readLine()) != null){
                sbResponse.append(sLine);
            }
            sResponse = sbResponse.toString();
        } catch (MalformedURLException ex) {
            Logger.getLogger(ToolBox.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(ToolBox.class.getName()).log(Level.SEVERE, null, ex);
        }
        return sResponse;
    }
    
    static ArrayList<stationData> getUniqueStations(List<stationData> stations){
        ArrayList<stationData> temp = new ArrayList<>();
        Set<String> uniques = new HashSet<>();
        
        for (stationData station : stations) {
            String addedAsString = new StringBuilder(String.valueOf(station.stationLocation.Lat))
                                                .append(String.valueOf(station.stationLocation.Lon))
                                                .toString();
            if (!uniques.contains(addedAsString)){
                uniques.add(addedAsString);
                temp.add(new stationData(station.stationLocation,station.stationName,station.weatherData));
            }
        }
        return temp;
    }
}

class Parser 
{
    private static List<String> getValueList(Document doc, XPath xpath, String expression)
    {
        List<String> list = new ArrayList<>();
        try {
            //create XPathExpression object
            XPathExpression expr = xpath.compile(expression);
            //evaluate expression result on XML document
            NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
            
//            NodeList nodeList = doc.getElementsByTagName("*");
//            for (int i = 0; i < nodeList.getLength(); i++) {
//                Node node = nodeList.item(i);
//                if (node.getNodeType() == Node.ELEMENT_NODE) {
//                    // do something with the current element
//                    System.out.println(node.getNodeName());
//                }
//            }
            
            for (int i = 0; i < nodes.getLength(); i++){
                //System.out.println(nodes.item(i).getTextContent().trim());
                list.add(nodes.item(i).getTextContent().trim());
            }
        } catch (XPathExpressionException ex) {
            Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
        return list;
    }
    
    static List<routeStep> getSteps(String gQuery) 
    {
        List<routeStep> list = new ArrayList<>();
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(gQuery);

            XPathFactory xPathfactory = XPathFactory.newInstance();
            XPath xpath = xPathfactory.newXPath();        
            String expr = "/DirectionsResponse/route/leg/step/start_location/lat/text()";
            // System.out.println(expr);
            List<String> start_lats = Parser.getValueList(doc, xpath, expr);
            expr = "/DirectionsResponse/route/leg/step/start_location/lng/text()";
            // System.out.println(expr);
            List<String> start_lngs = Parser.getValueList(doc, xpath, expr);
            expr = "/DirectionsResponse/route/leg/step/end_location/lat/text()";
            List<String> end_lats = Parser.getValueList(doc, xpath, expr);
            expr = "/DirectionsResponse/route/leg/step/end_location/lng/text()";
            List<String> end_lngs = Parser.getValueList(doc, xpath, expr);
            expr = "/DirectionsResponse/route/leg/step/distance/value/text()";
            List<String> dists = Parser.getValueList(doc, xpath, expr);
            expr = "/DirectionsResponse/route/leg/step/duration/value/text()";
            List<String> durs = Parser.getValueList(doc, xpath, expr);

            for (int i = 0; i < start_lats.size(); i++) {
//                System.out.println(start_lats.get(i));
//                System.out.println(start_lngs.get(i));
//                System.out.println(end_lats.get(i));
//                System.out.println(end_lngs.get(i));
//                System.out.println(dists.get(i));
//                System.out.println(durs.get(i));
                double slat = Double.parseDouble(start_lats.get(i));
//                System.out.println(start_lats.get(i));
//                System.out.println(slat);
                double slon = Double.parseDouble(start_lngs.get(i));
                Coordinates start = new Coordinates(slat, slon);
                double elat = Double.parseDouble(end_lats.get(i));
                double elon = Double.parseDouble(end_lngs.get(i));
                Coordinates end = new Coordinates(elat, elon);
                int dist = parseInt(dists.get(i));
                int dur = parseInt(durs.get(i));
                
                list.add(new routeStep(start, end, dist, dur));
            }
        } catch (ParserConfigurationException | SAXException | IOException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        return list;
    }
    
    static List<stationData> getStations(String fmiQuery) 
    {
        List<stationData> list = new ArrayList<>();  
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(fmiQuery);
            
            NodeList nodeList = doc.getElementsByTagName("BsWfs:BsWfsElement");
            for (int i = 0; i < nodeList.getLength(); i++) {
                //System.out.println(nodeList.item(i).getNodeName());
                NodeList nodeData = nodeList.item(i).getChildNodes();
                        
                Coordinates stationCoords = null;
                List<weatherData> weatherPoint = new ArrayList<>();
                weatherPoint.add(0, new weatherData("","",""));
                for (int j = 0; j < nodeData.getLength(); j++) {
                    switch (nodeData.item(j).getNodeName()) {
                        case "BsWfs:Location":
                            String Coords = nodeData.item(j).getTextContent().trim();
                            //System.out.println(Coords);
                            String[] splitCoords = Coords.split("[ ]");
                            stationCoords = new Coordinates(Double.parseDouble(splitCoords[0]),
                                                            Double.parseDouble(splitCoords[1]));
                            break;
                        case "BsWfs:Time":
                            weatherPoint.get(0).isoTime = nodeData.item(j).getTextContent().trim();
                            break;
                        case "BsWfs:ParameterName":
                            weatherPoint.get(0).parameterName = nodeData.item(j).getTextContent().trim();
                            break;
                        case "BsWfs:ParameterValue":
                            weatherPoint.get(0).parameterValue = nodeData.item(j).getTextContent().trim();
                            break;
                    }
                }
                list.add(new stationData(stationCoords, "", weatherPoint));
            }
        } catch (SAXException | IOException | ParserConfigurationException ex) {
            Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
        return list;
    }
    
    static String getStationName(String geoQuery){
        String name = new String();
        String backupName = new String();
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(geoQuery);
            
            NodeList statusCheck = doc.getElementsByTagName("status");
            //System.out.println(statusCheck.item(0).getTextContent().trim());
            if (statusCheck.item(0).getTextContent().trim().equals("OK")){
                NodeList nodeList = doc.getElementsByTagName("address_component");
                for (int i = 0; i < nodeList.getLength(); i++) {
                    //System.out.println(nodeList.item(i).getNodeName());
                    NodeList nodeData = nodeList.item(i).getChildNodes();
                    Boolean nameFound = FALSE;
                    for (int j = 0; j < nodeData.getLength(); j++) {
                        //System.out.println(nodeData.item(j).getTextContent().trim());
                        switch (nodeData.item(j).getNodeName()) {
                            case "long_name":
                                name = nodeData.item(j).getTextContent().trim();
                                //System.out.println("Name changed to: "+name);
                            case "type":
                                if (nodeData.item(j).getTextContent().trim().equals("locality") || 
                                        nodeData.item(j).getTextContent().trim().equals("administrative_area_level_3")){
                                    nameFound = TRUE;
                                    System.out.println("Locality or Adm.area3 found. Saving name: "+name);
                                }
                                else if(nodeData.item(j).getTextContent().trim().equals("administrative_area_level_2")){
                                    backupName = name;
                                    System.out.println("backupName set to: "+backupName);
                                }
                        }
                    }
                    if (nameFound){
                        return name;
                    }
                }
            }
        } catch (SAXException | IOException | ParserConfigurationException ex) {            
            Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println("End of file, returning backupName: "+backupName);
        return backupName;
    }
}

class FileSystemTools{
    static void saveObjectToFile(Object object, File fileName){
        System.out.println("Saving object to file: "+fileName);
        try {
            FileOutputStream fout = new FileOutputStream(fileName);
            ObjectOutputStream oos = new ObjectOutputStream(fout);
            oos.writeObject(object);
            fout.close();
            oos.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println("Saved file: "+fileName);
    }
    static List<stationData> loadStationsFromFile(File stationFileName){
        List<stationData> savedStations = new ArrayList<>();
        try {
            FileInputStream fin = new FileInputStream(stationFileName);
            ObjectInputStream ois = new ObjectInputStream(fin);
            savedStations = (List<stationData>) ois.readObject();
            fin.close();
            ois.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException | ClassNotFoundException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        return savedStations;
    }
    static Boolean isSavedRoute(String gQuery){
        if (FmiQueryTest.routeFileName.exists()){
            gQuery = gQuery.replace(FmiQueryTest.gDirectionQuery, "");
            gQuery = gQuery.replace(FmiQueryTest.gKey, "");
            gQuery = gQuery.replace("&key=", "");
            //Find gQuery from the file
            List<String> queries = readLinesFromFile(FmiQueryTest.routeFileName);
            for (String query : queries){
                if (query.equals(gQuery)){
                    System.out.println("Route found from saved list.");
                    return TRUE;
                }
            }
        }
        return FALSE;
    }
    static List<routeStep> loadSavedRoute(String gQuery){
        List<routeStep> loadedRoute = new ArrayList<>();
        gQuery = gQuery.replace(FmiQueryTest.gDirectionQuery, "");
        gQuery = gQuery.replace(FmiQueryTest.gKey, "");
        gQuery = gQuery.replace("&key=", "");
        File savedFileName = new File(gQuery.replaceAll("[^A-Za-z0-9 ]", "")+".txt");
        //Load route
        try {
            FileInputStream fin = new FileInputStream(savedFileName);
            ObjectInputStream ois = new ObjectInputStream(fin);
            loadedRoute = (List<routeStep>) ois.readObject();
            fin.close();
            ois.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException | ClassNotFoundException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        return loadedRoute;
    }
    static void saveRoute(String gQuery, List<routeStep> gSteps){
        gQuery = gQuery.replace(FmiQueryTest.gDirectionQuery, "");
        gQuery = gQuery.replace(FmiQueryTest.gKey, "");
        gQuery = gQuery.replace("&key=", "");
        //Save gQuery
        FileSystemTools.appendLineToFile(gQuery, FmiQueryTest.routeFileName);
        //Save gSteps
        File savedFileName = new File(gQuery.replaceAll("[^A-Za-z0-9 ]", "")+".txt");
        FileSystemTools.saveObjectToFile(gSteps, savedFileName);
    }
    static void appendLineToFile(String gQuery, File file){
        try {
            // if file doesnt exists, then create it
            if (!file.exists()) {
                file.createNewFile();
            }
            FileWriter fw = new FileWriter(file.getAbsoluteFile(), true);
            BufferedWriter bw = new BufferedWriter(fw);
            bw.write(gQuery+FmiQueryTest.newLine);
            bw.close();

            System.out.println("Saved route to "+file.getName());
        } catch (IOException ex) {
            Logger.getLogger(FileSystemTools.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    static List<String> readLinesFromFile(File file){
        List<String> lines = new ArrayList<String>();
        try {
            FileReader fileReader;
            fileReader = new FileReader(file);
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            String line = null;
            while ((line = bufferedReader.readLine()) != null) {
                lines.add(line);
            }
            bufferedReader.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FileSystemTools.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(FileSystemTools.class.getName()).log(Level.SEVERE, null, ex);
        }
        return lines;
    }
    static List<stationData> extractHourOfWeatherData(String savedFileTime, List<stationData> fmiData){
        List<stationData> thisHourData = new ArrayList<>();
        System.out.println("savedFileTime: "+savedFileTime);
        for (stationData line : fmiData){
            for (weatherData data : line.weatherData){
                List<weatherData> weatherPoint = new ArrayList<>();
                if(data.isoTime.equals(savedFileTime)){
                    weatherPoint.add(0, data);
                    thisHourData.add(new stationData(line.stationLocation,line.stationName,weatherPoint));
                }
            }
        }
        return thisHourData;
    }
    static void cleanupOldWeatherData(int daysToStoreWeatherData){
        DateFormat df_daycode = new SimpleDateFormat("yyyyMMdd");
        int cleanUpTime = parseInt(df_daycode.format(new Date(System.currentTimeMillis() - ((daysToStoreWeatherData*24*3600) * 1000))));
        File dir = new File(".");
        FilenameFilter filter = new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.startsWith("weather");
            }
        };
        String[] weatherFiles = dir.list(filter);
        System.out.println("Cleaning up old weather data from directory:");
        for (String file : weatherFiles){
            System.out.print(file);
            int currentDayCode = parseInt(file.replaceAll("weather", "").substring(0,8));
            if (currentDayCode <= cleanUpTime){
                try {
                    Files.delete(FileSystems.getDefault().getPath(file));
                } catch (IOException ex) {
                    Logger.getLogger(FileSystemTools.class.getName()).log(Level.SEVERE, null, ex);
                }
                System.out.println(" - was removed.");
            }else{
                System.out.println(" - was kept.");
            }
        }   
    }
}
class WeatherTools{
    //    Data structure
    //    hmap (keys: String isoTime-parameterName)
    //      parameterValue
    static Map extractNeededStations(Set<Integer> uniqueEntries, List<stationData> fmiData, List<stationData> allStations){
        //Prepare returned HashMap
        HashMap<String, String> hmap = new HashMap<>();
        //Prepare HashMap for Coordinates-Integer pairs
        HashMap<String, Integer> idMap = new HashMap<>();
        
        //Prepare inner HashMap for every station (keys: isotimes)
        for (Integer stationNum : uniqueEntries){
            //Save needed stations as Coordinates
            String coor = allStations.get(stationNum).stationLocation.Lat+"-"+allStations.get(stationNum).stationLocation.Lon;
            idMap.put(coor, stationNum);
        }
        //Save all needed weather data
        for (stationData station : fmiData){
            //Use idMap to check if current station is needed
            String coor = station.stationLocation.Lat+"-"+station.stationLocation.Lon;
            //System.out.println(coor);
            if(idMap.containsKey(coor)){
                //If it is, save any weather data found here
                Integer stationNum = idMap.get(coor);
                for(weatherData weather : station.weatherData){
                    //System.out.format("%-25s%-35s%-20s\n",weather.isoTime,weather.parameterName,weather.parameterValue);
                    hmap.put(stationNum+"-"+weather.isoTime+"-"+weather.parameterName, weather.parameterValue);
                } 
            }
        }
        return hmap;
    }
}

public class FmiQueryTest {
    static String gKey = "AIzaSyBceB0at3czeTt5BWnL7FQvmf_AEBxLjys";
    static String fmiKey = "2dcc4c13-ee27-4471-b5b1-73623eb933e4";
    static String gDirectionQuery = "https://maps.googleapis.com/maps/api/directions/xml?";
    static String fmiBase = "http://data.fmi.fi/fmi-apikey/";
    static String fmiMiddle = "/wfs?request=getFeature&storedquery_id=";
    static String fmiQueryCities = "fmi::forecast::hirlam::surface::cities::simple";
    static String fmiQueryObsStations = "fmi::forecast::hirlam::surface::obsstations::simple";
    static String newLine = System.getProperty("line.separator");//This will retrieve line separator dependent on OS.
    static File stationFileName = new File("stationnames.txt");
    static File routeFileName = new File("savedroutes.txt");
    static File resultFileName = new File("index.html");
    static Integer routeDur = 0;
    
    public static void main(String[] args) {
        //INPUTS AND SETTINGS
        String gOrigin = "Etel%C3%A4inen+Hesperiankatu+20,+00100+Helsinki,+Finland";
//        String gDestination = "33100+Tampere";
        String gDestination = "Utsjoki";
        TimeZone tz = TimeZone.getTimeZone("GMT+2");
        DateFormat df_short = new SimpleDateFormat("HH:mm");
        df_short.setTimeZone(tz);
//        String startTime = df_short.format(new Date());
//        System.out.println("startTime: "+startTime);
        long systemTimeMillis = System.currentTimeMillis();
        int daysToStoreWeatherData = 1;
        int refreshInterval = 15*60; //seconds
        
        //Clean up old weather data 
        FileSystemTools.cleanupOldWeatherData(daysToStoreWeatherData);

        //Google query
        //**********************************************************************
        String gQuery = new StringBuilder(gDirectionQuery).append("origin=")
                .append(gOrigin).append("&destination=").append(gDestination)
                .append("&key=").append(gKey).toString();
        System.out.println("Google query URL: "+gQuery);
        
        //Check if we already have this route
        List<routeStep> gSteps = new ArrayList<>();
        if(FileSystemTools.isSavedRoute(gQuery)){
            gSteps = FileSystemTools.loadSavedRoute(gQuery);
        }
        else {
            gSteps = Parser.getSteps(gQuery);
            FileSystemTools.saveRoute(gQuery, gSteps);
        }
        
        //Compile route table
        //**********************************************************************
        List<routeStep> routeData = RouteTools.compileRoute(gSteps, refreshInterval);        
        String endTime = df_short.format(new Date(systemTimeMillis + routeDur * 1000));
        System.out.println("endTime: "+endTime);
        
        //ISO time format
        //**********************************************************************
        DateFormat df_iso = new SimpleDateFormat("yyyy-MM-dd'T'HH:00:00'Z'");
        df_iso.setTimeZone(tz);
        String nowAsISO = df_iso.format(new Date());
        System.out.println("Start ISO time: "+nowAsISO);
        double timeMarginal = routeDur*1.2+3600;
        String endTimeForFmi = df_iso.format(new Date(systemTimeMillis + (intValue(timeMarginal)) * 1000));
        System.out.println("End ISO time:   "+endTimeForFmi);
        String fmiParam = new StringBuilder("&starttime=").append(nowAsISO)
                .append("&endtime=").append(endTimeForFmi).toString();
        
        //Check if we even need to download FMI data
        File weatherDataFileNameStart = new File("weather"+nowAsISO.replaceAll("[^A-Za-z0-9 ]", "")+".txt");
        File weatherDataFileNameEnd = new File("weather"+endTimeForFmi.replaceAll("[^A-Za-z0-9 ]", "")+".txt");
        List<stationData> allStations = new ArrayList<>();
        List<stationData> fmiData = new ArrayList<>();
        List<String> savedFileTimes = new ArrayList<>();
        
        //Check if we already have the weather data
        if(!weatherDataFileNameStart.exists() || !weatherDataFileNameEnd.exists()){
            //FMI query
            //**********************************************************************
            String fmiCities        = new StringBuilder(fmiBase).append(fmiKey)
                    .append(fmiMiddle).append(fmiQueryCities)
                    .append(fmiParam).toString();
            String fmiObsStations   = new StringBuilder(fmiBase).append(fmiKey)
                    .append(fmiMiddle).append(fmiQueryObsStations)
                    .append(fmiParam).toString();
//            System.out.println("FMI cities URL: "+fmiCities);
//            System.out.println("FMI obsstations URL: "+fmiObsStations);

            //Collect weather data from FMI
            //**********************************************************************
            System.out.print("FMI data:"+newLine+fmiCities+newLine+"Loading and processing...");
            fmiData.addAll(Parser.getStations(fmiCities));
            System.out.println("SUCCESS.");
            System.out.print("FMI data:"+newLine+fmiObsStations+newLine+"Loading and processing...");
            fmiData.addAll(Parser.getStations(fmiObsStations));
            System.out.println("SUCCESS.");

            //Get unique stations
            //**********************************************************************
            List<stationData> uniqueStations = ToolBox.getUniqueStations(fmiData);
            System.out.println("Parsed stations count: " + uniqueStations.size());

            //Save or load stations
            //**********************************************************************
            List<stationData> savedStations = new ArrayList<>();
            if (!stationFileName.exists()){
                //Save current parsed stations to file
                FileSystemTools.saveObjectToFile(uniqueStations, stationFileName);
            }
            else {
                //Or if the stations were already saved, load them
                System.out.println("Station information file found: "+stationFileName);
                System.out.print("Loading...");
                savedStations = FileSystemTools.loadStationsFromFile(stationFileName);
                System.out.println("DONE.");
                System.out.println("Loaded stations count: " + savedStations.size());
            }

            //Merge station information
            //**********************************************************************
            System.out.println("Merging station information.");
            savedStations.addAll(uniqueStations);
            allStations = ToolBox.getUniqueStations(savedStations);
            System.out.println("Merged stations count: " + allStations.size());

            //Find names for stations
            //**********************************************************************
            String gMapsGeoCode = "https://maps.googleapis.com/maps/api/geocode/xml?latlng=";
            //for (stationData station : allStations){
            for(int i=0; i < allStations.size();i++){
                if (allStations.get(i).stationName.equals("")){
                    gQuery = new StringBuilder(gMapsGeoCode).append(allStations.get(i).stationLocation.Lat)
                            .append(",").append(allStations.get(i).stationLocation.Lon)
                            .append("&key=").append(gKey).toString();
                    System.out.println("Google query URL: "+gQuery);

                    allStations.get(i).stationName = Parser.getStationName(gQuery);
                }
            }
            //System.out.println("Station names parsed.");

            //Print stations and separate them for saving
            //**********************************************************************
            List<stationData> onlyStations = new ArrayList<>();
//            int indeksi = 0;
            List<weatherData> weatherPoint = new ArrayList<>();
            weatherPoint.add(0, new weatherData("","",""));
            for(stationData station : allStations){
//                System.out.format("%-4s%-30s%-10s%-10s\n",
//                                    indeksi,station.stationName,station.stationLocation.Lat,station.stationLocation.Lon);
//                ++indeksi;
                onlyStations.add(new stationData(station.stationLocation, station.stationName, weatherPoint));
            }

            //Save station names
            //**********************************************************************
            System.out.println("Saving station names.");
            FileSystemTools.saveObjectToFile(onlyStations, stationFileName);

            //Save weather dataset
            //**********************************************************************
            //Compute file names between start and end
            System.out.println("Saving weather data...");
            File weatherDataFileNameTemp = weatherDataFileNameStart;
            int hoursPassed = 0;
            while (!weatherDataFileNameTemp.equals(weatherDataFileNameEnd)){
                String savedFileTime = df_iso.format(new Date(systemTimeMillis + ((hoursPassed*3600) * 1000)));
                savedFileTimes.add(savedFileTime);
                weatherDataFileNameTemp = new File("weather"+savedFileTime.replaceAll("[^A-Za-z0-9 ]", "")+".txt");
                System.out.println("Weather data file: "+weatherDataFileNameTemp);
                if (!weatherDataFileNameTemp.exists()){
                    List<stationData> thisHourWeather = FileSystemTools.extractHourOfWeatherData(savedFileTime, fmiData);
                    System.out.println("Saving: "+weatherDataFileNameTemp);
                    FileSystemTools.saveObjectToFile(thisHourWeather, weatherDataFileNameTemp);
                }
                ++hoursPassed;
            }
        }
        //If we have weather data saved, definitely we have the stations also
        else {
            System.out.println("Loading weather data...");
            File weatherDataFileNameTemp = weatherDataFileNameStart;
            int hoursPassed = 0;
            while (!weatherDataFileNameTemp.equals(weatherDataFileNameEnd)){
                String savedFileTime = df_iso.format(new Date(systemTimeMillis + ((hoursPassed*3600) * 1000)));
                savedFileTimes.add(savedFileTime);
                weatherDataFileNameTemp = new File("weather"+savedFileTime.replaceAll("[^A-Za-z0-9 ]", "")+".txt");
                System.out.println("Weather data file: "+weatherDataFileNameTemp);
                if (weatherDataFileNameTemp.exists()){
                    fmiData.addAll(FileSystemTools.loadStationsFromFile(weatherDataFileNameTemp));
                }
                ++hoursPassed;
            }
            allStations = FileSystemTools.loadStationsFromFile(stationFileName);
            System.out.println("DONE.");
        }
        
        //Find closest weather stations in route points
        System.out.println("Calculating nearest stations in route points:");
        List<Integer> neededStations = new ArrayList<>();
        for (routeStep step : routeData){
            distance[] stationDistances = RouteTools.calculateStationDistances(step.StartLocation, allStations);
            System.out.format("%-6s%-12s%-12s\n","Step: ",step.StartLocation.Lat,step.StartLocation.Lon);
            for( int i=0;i<1;i++){
                System.out.format("%-9s%-5s%-20s%-20s\n",
                                    "Station: ",stationDistances[i].stationNum,
                                    allStations.get(stationDistances[i].stationNum).stationName,
                                    stationDistances[i].stationDistance);
            }
            neededStations.add(stationDistances[0].stationNum);
        }
        System.out.println("Needed stations: "+neededStations.toString().trim());
        
        //Remove duplicates from needed stations list
        Set<Integer> uniqueEntries = new HashSet<Integer>(neededStations);
        //Extract weather data from needed stations
        Map routeWeather = Collections.synchronizedMap(new HashMap());
        routeWeather = WeatherTools.extractNeededStations(uniqueEntries, fmiData, allStations);
        String nameToFind = "Temperature";
//        for(Integer num : uniqueEntries){
//            for(String time : savedFileTimes){
//                System.out.println(num+" "+time+" "+routeWeather.get(num+"-"+time+"-"+nameToFind));
//            }
//        }

        //Make a webpage with the weather data
        try {
            // if file doesnt exists, then create it
            if (!resultFileName.exists()) {
                resultFileName.createNewFile();
            }
            FileWriter fw = new FileWriter(resultFileName.getAbsoluteFile(), false);
            BufferedWriter bw = new BufferedWriter(fw);

            bw.write(
                        "<!DOCTYPE html>\n" +
                        "<html>\n" +
                        "  <head>\n" +
                        "    <meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=no\">\n" +
                        "    <meta charset=\"utf-8\">\n" +
                        "    <title>Weather en Route</title>\n" +
                        "    <style>\n" +
                        "      html, body {\n" +
                        "        height: 100%;\n" +
                        "        margin: 0;\n" +
                        "        padding: 0;\n" +
                        "      }\n" +
                        "      #map {\n" +
                        "        height: 100%;\n" +
                        "      }\n" +
                        "    </style>\n" +
                        "  </head>\n" +
                        "  <body>\n" +
                        "    <div id=\"map\"></div>\n" +
                        "    <script>\n" +
                        "  function initMap() {\n");
               bw.write("  var siikalatva = {lat: 64.179265, lng: 25.804715};\n" +
                        "  var map = new google.maps.Map(document.getElementById('map'), {\n" +
                        "    zoom: 6,\n" +
                        "    center: siikalatva,\n" +
                        "    zoomControl: true,\n" +
                        "    scaleControl: true,\n" +    
                        "    streetViewControl: true,\n" +
                        "    mapTypeControl: true,\n" +
                        "    mapTypeControlOptions: {\n" +
                        "      style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,\n" +
                        "      mapTypeIds: [\n" +
                        "        google.maps.MapTypeId.ROADMAP,\n" +
                        "        google.maps.MapTypeId.TERRAIN\n" +
                        "      ]\n" +
                        "    }\n" +
                        "  });\n");
bw.write("  var directionsService = new google.maps.DirectionsService;\n" +
"  var directionsDisplay = new google.maps.DirectionsRenderer({\n" +
"    draggable: false,\n" +
"    map: map\n" +
"  });");
bw.write("  displayRoute('"+gOrigin+"', '"+gDestination+"', directionsService,\n" +
"      directionsDisplay);");
//bw.write("  var markerArray = [];\n" +
//"  // Instantiate a directions service.\n" +
//"  var directionsService = new google.maps.DirectionsService;\n" +
//"  // Create a renderer for directions and bind it to the map.\n" +
//"  var directionsDisplay = new google.maps.DirectionsRenderer({map: map});\n" +
//"  // Instantiate an info window to hold step text.\n" +
//"  var stepDisplay = new google.maps.InfoWindow;\n" +
//"  // Display the route between the initial start and end selections.\n" +
//"  calculateAndDisplayRoute(\n" +
//"      directionsDisplay, directionsService, markerArray, stepDisplay, map);\n" +
//"  // Listen to change events from the start and end lists.\n" +
//"  var onChangeHandler = function() {\n" +
//"    calculateAndDisplayRoute(\n" +
//"        directionsDisplay, directionsService, markerArray, stepDisplay, map);\n" +
//"  };\n" +
//"  document.getElementById('start').addEventListener('change', onChangeHandler);\n" +
//"  document.getElementById('end').addEventListener('change', onChangeHandler); \n");
            Integer totalDur = 0;
            for (int i=0;i<routeData.size();++i){
                String weatherTimeNow = df_iso.format(new Date(systemTimeMillis + totalDur * 1000));
                String weatherTimeNext = df_iso.format(new Date(systemTimeMillis + (totalDur+3600) * 1000));
                Integer nearestStationNow = neededStations.get(i);
    //            Integer nearestStationNext = neededStations.get(i);
    //            if(i<routeData.size()-1){
    //                nearestStationNext = neededStations.get(i+1);
    //            }
                double pointNow = Double.parseDouble(routeWeather.get(nearestStationNow+"-"+weatherTimeNow+"-"+nameToFind).toString());
                //System.out.println(nearestStationNow+"-"+weatherTimeNow+"-"+nameToFind+": "+pointNow);
                double pointNext = pointNow;
                try {
                    pointNext = Double.parseDouble(routeWeather.get(nearestStationNow+"-"+weatherTimeNext+"-"+nameToFind).toString());
                    //System.out.println(nearestStationNow+"-"+weatherTimeNext+"-"+nameToFind+": "+pointNext);
                } catch (NullPointerException ex) {
                    //System.out.println("Next hourly datapoint was not found: "+ex.getMessage());
                }
                //System.out.println("Fraction: "+(totalDur.doubleValue()%3600/3600));
                double pointMiddle = pointNow+(pointNext-pointNow)*(totalDur.doubleValue()%3600/3600);
                DecimalFormat df_oneDecimal = new DecimalFormat("#.0");
                bw.write(
                        "  var station"+i+" = '<div id=\"content"+i+"\"><pre>'+");
                bw.write("'Station:     "+allStations.get(nearestStationNow).stationName+"<br>'+");
                bw.write("'Coordinates: "+allStations.get(nearestStationNow).stationLocation.Lat
                                                                +" "+allStations.get(nearestStationNow).stationLocation.Lon+"<br>'+");
                bw.write("'Time:        "+df_short.format(new Date(systemTimeMillis + totalDur * 1000))+"<br>'+");
                bw.write("'"+nameToFind+": "+df_oneDecimal.format(pointMiddle)+"<br>'+");
                bw.write("'</pre></div>';");
                bw.write(
                        "  var infowindow"+i+" = new google.maps.InfoWindow({\n" +
                        "    content: station"+i+",\n" +
                        "    maxWidth: 300\n" +
                        "  });");
                bw.write("  var position"+i+" = {lat: "+allStations.get(nearestStationNow).stationLocation.Lat
                        +", lng: "+allStations.get(nearestStationNow).stationLocation.Lon+"};");
                bw.write(
                        "  var marker"+i+" = new google.maps.Marker({\n" +
                        "    position: position"+i+",\n" +
                        "    map: map,\n" +
                        "    title: '"+allStations.get(nearestStationNow).stationName+"'\n" +
                        "  });");
                bw.write(
                        "  marker"+i+".addListener('click', function() {\n" +
                        "    infowindow"+i+".open(map, marker"+i+");\n" +
                        "  });");
                bw.write("infowindow"+i+".open(map, marker"+i+");\n");
                totalDur += routeData.get(i).Duration;        
            }
            bw.write("  }\n");
bw.write("function displayRoute(origin, destination, service, display) {\n" +
"  service.route({\n" +
"    origin: origin,\n" +
"    destination: destination,\n" +
"    travelMode: google.maps.TravelMode.DRIVING\n" +
"  }, function(response, status) {\n" +
"    if (status === google.maps.DirectionsStatus.OK) {\n" +
"      display.setDirections(response);\n" +
"    } else {\n" +
"      alert('Could not display directions due to: ' + status);\n" +
"    }\n" +
"  });\n" +
"}");
//bw.write("function calculateAndDisplayRoute(directionsDisplay, directionsService,\n" +
//"    markerArray, stepDisplay, map) {\n" +
//"  // First, remove any existing markers from the map.\n" +
//"  for (var i = 0; i < markerArray.length; i++) {\n" +
//"    markerArray[i].setMap(null);\n" +
//"  }\n" +
//"\n" +
//"  // Retrieve the start and end locations and create a DirectionsRequest using\n" +
//"  // WALKING directions.\n" +
//"  directionsService.route({\n" +
//"    origin: document.getElementById('start').value,\n" +
//"    destination: document.getElementById('end').value,\n" +
//"    travelMode: google.maps.TravelMode.WALKING\n" +
//"  }, function(response, status) {\n" +
//"    // Route the directions and pass the response to a function to create\n" +
//"    // markers for each step.\n" +
//"    if (status === google.maps.DirectionsStatus.OK) {\n" +
//"      document.getElementById('warnings-panel').innerHTML =\n" +
//"          '<b>' + response.routes[0].warnings + '</b>';\n" +
//"      directionsDisplay.setDirections(response);\n" +
//"      showSteps(response, markerArray, stepDisplay, map);\n" +
//"    } else {\n" +
//"      window.alert('Directions request failed due to ' + status);\n" +
//"    }\n" +
//"  });\n" +
//"}\n" +
//"\n" +
//"function showSteps(directionResult, markerArray, stepDisplay, map) {\n" +
//"  // For each step, place a marker, and add the text to the marker's infowindow.\n" +
//"  // Also attach the marker to an array so we can keep track of it and remove it\n" +
//"  // when calculating new routes.\n" +
//"  var myRoute = directionResult.routes[0].legs[0];\n" +
//"  for (var i = 0; i < myRoute.steps.length; i++) {\n" +
//"    var marker = markerArray[i] = markerArray[i] || new google.maps.Marker;\n" +
//"    marker.setMap(map);\n" +
//"    marker.setPosition(myRoute.steps[i].start_location);\n" +
//"    attachInstructionText(\n" +
//"        stepDisplay, marker, myRoute.steps[i].instructions, map);\n" +
//"  }\n" +
//"}\n" +
//"\n" +
//"function attachInstructionText(stepDisplay, marker, text, map) {\n" +
//"  google.maps.event.addListener(marker, 'click', function() {\n" +
//"    // Open an info window when the marker is clicked on, containing the text\n" +
//"    // of the step.\n" +
//"    stepDisplay.setContent(text);\n" +
//"    stepDisplay.open(map, marker);\n" +
//"  });\n" +
//"}\n");
               bw.write("    </script>\n" +
                        "    <script async defer\n" +
                        "        src=\"https://maps.googleapis.com/maps/api/js?key=AIzaSyDvB2p97Ee-USxdOsOTyCa50HnW8H4PlRQ&signed_in=true&callback=initMap\"></script>\n" +
                        "  </body>\n" +
                        "</html>");
            
            bw.close();
        } catch (IOException ex) {
            System.err.println("Something went wrong: "+ex.getMessage());
        }
        try {
            //Open the file
            Desktop.getDesktop().browse(resultFileName.toURI());
        } catch (IOException ex) {
            Logger.getLogger(FmiQueryTest.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}
